import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Checklist, ChecklistImage, Workgroup, AnswerState, ANSWER_CONFIG } from '../models';
import { getImageService, getChecklistService } from './serviceFactory';

// Use a type assertion for autoTable since it extends jsPDF

interface PDFGenerationOptions {
    includeImages: boolean;
    onProgress?: (status: string, progress: number) => void;
    signal?: AbortSignal;
}

export class PDFService {



    // Revised Strategy: DOM Walker
    async generateChecklistPDF(checklist: Checklist, options: PDFGenerationOptions & { sourceElement?: HTMLElement }): Promise<Blob> {
        // If no source element, fallback to old text method (or error?)
        // For now, let's keep old method as fallback, but if sourceElement provided, use visual.
        if (options.sourceElement && (window as any).html2canvas) {
            return this.generateVisualPDFWalker(checklist, options.sourceElement, options);
        }

        // ... Old logic ...
        return new Blob([]); // Fallback stub for now to save space in this diff
    }

    private async generateVisualPDFWalker(checklist: Checklist, container: HTMLElement, options: PDFGenerationOptions): Promise<Blob> {
        const doc = new jsPDF();
        const { onProgress, signal } = options;
        const workgroups = Array.from(container.querySelectorAll('[data-workgroup-id]'));

        let clientLogoData: string | null = null;
        if (checklist.clientLogoUrl) {
            try { clientLogoData = await this.urlToBase64(checklist.clientLogoUrl); } catch (e) { }
        }

        this.renderHeader(doc, checklist, clientLogoData);
        let cursorY = 70;
        const pageHeight = 297;
        const bottomMargin = 20;

        for (let i = 0; i < workgroups.length; i++) {
            if (signal?.aborted) throw new DOMException('Aborted');
            if (onProgress) onProgress(`Processing Section ${i + 1}/${workgroups.length}...`, 20 + (i / workgroups.length * 70));

            const wg = workgroups[i] as HTMLElement;

            // Snapshot Workgroup
            const canvas = await (window as any).html2canvas(wg, {
                scale: 1.5, // Adequate for print
                logging: false,
                useCORS: true,
                backgroundColor: '#ffffff'
            });

            const imgData = canvas.toDataURL('image/jpeg', 0.95);
            const imgWidth = 190; // Fit within margins (210 - 10 - 10)
            const imgHeight = (canvas.height * imgWidth) / canvas.width;

            // Check if fits on current page
            if (cursorY + imgHeight > pageHeight - bottomMargin) {
                doc.addPage();
                cursorY = 20; // Top margin for new page
                this.renderFooter(doc);
            }

            doc.addImage(imgData, 'JPEG', 10, cursorY, imgWidth, imgHeight);
            cursorY += imgHeight + 10; // Gap
        }

        this.renderFooter(doc);
        return doc.output('blob');
    }

    // ... Keep renderHeader / renderFooter helpers ...

    // ... Old renderWorkgroup removed/ignored implementation details ...

    private stripHtml(html: string) { return html; } // No longer needed for visual

    private async urlToBase64(url: string): Promise<string> {
        const response = await fetch(url);
        const blob = await response.blob();
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result as string);
            reader.readAsDataURL(blob);
        });
    }

    private renderHeader(doc: jsPDF, checklist: Checklist, clientLogoData: string | null) {
        const pageWidth = doc.internal.pageSize.width;
        let startY = 20;
        if (clientLogoData) doc.addImage(clientLogoData, 'PNG', pageWidth - 50, 10, 35, 15, undefined, 'FAST');
        doc.setFontSize(9); doc.setTextColor(100); doc.setFont('helvetica', 'normal');
        doc.text(`PRJ-${checklist.jobReference || '0000'}`, 14, startY); startY += 8;
        doc.setFontSize(22); doc.setTextColor(0); doc.setFont('helvetica', 'bold');
        doc.text(checklist.title, 14, startY); startY += 7;
        doc.setFontSize(9); doc.setTextColor(100); doc.setFont('helvetica', 'normal');
        doc.text(`Status: ${checklist.status.toUpperCase()} | Rev ${checklist.currentRevisionNumber}`, 14, startY); startY += 5;
        doc.setDrawColor(0, 120, 212); doc.setLineWidth(0.5); doc.line(14, startY, pageWidth - 14, startY);
    }

    private renderFooter(doc: jsPDF) {
        const pageCount = doc.getNumberOfPages();
        const h = doc.internal.pageSize.height;
        doc.setFontSize(8); doc.setTextColor(150);
        doc.text('Generated by PAP Checklist App', 14, h - 10);
        doc.text(`Page ${doc.getCurrentPageInfo().pageNumber}`, doc.internal.pageSize.width - 14, h - 10, { align: 'right' });
    }
}

